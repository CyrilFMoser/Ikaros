- Type trait, 
    
    - allows for subtyping

    - access to parameters,typearguments etc
    
    - allows for instantiation
    
    - get_types function, returns a template vector with all available types as templates
    
    - get_prelude_types function, returns a vector of types that are always present in the program (primitives for example)
    
    - set_id function, sets the id of a type. This is useful if we want to add infinite recursive types
    
    - match_against function, to filter out the types that we want to match against (traits, case classes)
    
    - is_base function, to filter out the types that can have subcases and should be decalred (traits, but not type unions of traits e.g)
    
    - get_case_templates function, takes a Template of a type and returns its case types as templates 
        (Scala: trait template -> case class templates)
    
    - allows_base_instantiation function, returns if a (type, but intended for base) base can be instantiated
      to give a new base (as in scala traits) 

    - allows_multiple_bases function, returns if a type is able to be a subcase of multiple bases (case classes in scala can, haskell variants can't)
    
    - can_have_own_typargs function, returns if a type can add its own type arguments (Scala case classes can, haskell variants can't)
    
    - is_local function, returns if a type is useable outside of the declaration (Scala case classes are, haskell variants aren't)
    
    - refineable function, returns if a type can be refined into new cases (traits into case classes, *OR* type combinations of
      refineable types such as type unions)

    - is_complex function: returns if we consider a type to be complex (traits, case classes for example)

    - needs_declaration function: reutrns if a type needs a declaration for us to use it (case classes, but not type unions)


- Each language implements it with an enum

- Generator stores:
    - available_types // indices of types in all_types that are available for generation of new types
    - all_types // all generated types and get_prelude_types

- function add_type(type)
    - if not type.is_local():
        - add type to available_types // For this and below, first check if an alpha equivalent type already exists, if so don't add it.
    - add type to all_types

// generates bases and their variants

- function generate_bases()
    - list of bases with only base templates filtered out
    - for each such base:
        - Choose a number of type arguments and add them
        - add_type(base)
        - if allows_base_instantiation AND we want to instantiate:
                - Instantiate some of the type arguments of the base
                - Add this base to list of bases from before
                - add_type(new_base)

    - for each base we choose to generate:
        - templates = get_case_templates() to get the case templates for this base
        - for each case we choose to generate for this base:
                - case_template <- get_random(templates)
                - add generics of the base to typargs of case
                - case.bases add base
                - if case.allows_multiple_bases AND we want to extends multiple bases:
                    - for each extra base:
                        - select a random new base of our list above
                        - add it to case.bases
                        - add typargs of new base to case
                - if can_have_own_typargs(case_template) AND we want to add a typarg:
                    - add typarg to typargs of case
                - if case.get_parameters() is not None:
                    - num_parameters = rng
                    - case.set_parameter(generate_parameters(num_parameters,case.typargs))
                - add_type(case)

- function generate_type(typargs,depth)
    - Decide if we want to use prelude_type, if so simply return that
    - if we want to use an available complex type:
        - if the complex type has typargs, replace them with the new typargs
        - Decide if we want to instantiate some of the type arguments with new types (limit the depth)
    - otherwise generate a new type that does not need a declaration (again limit depth)

- function generate_graph()
    - all_types = union(available_types,custom_types)
    - for each combination of pairs t1,t2 in all_types:
        - if t1 != t2:
            - if get_instantiation(t1,t2) is valid: // instantiation from t1 -> t2 exists and is valid, could also just be a subtype
                - graph.add_edge(t1,t2,substitution)


- function generate_match()
    - get some interesting type that is refineable
    - Then simply proceed as in the previous scala pattern match generator.